# Rc\<T\>

**Rc\<T\>** (Reference Counted) ‡πÉ‡∏´‡πâ‡∏´‡∏•‡∏≤‡∏¢ owners ‡πÑ‡∏î‡πâ ‡πÉ‡∏ä‡πâ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ share ownership

## ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏´‡∏£‡πà‡πÉ‡∏ä‡πâ Rc?

‡∏õ‡∏Å‡∏ï‡∏¥ Rust ‡∏°‡∏µ owner ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß ‡πÅ‡∏ï‡πà‡∏ö‡∏≤‡∏á‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏´‡∏•‡∏≤‡∏¢ owners:

```text
      +-----+
      |  a  |
      +--+--+
         |
      +--v--+
      |  5  |<-- want b and c to share this too
      +-----+
         ^
    +----+----+
 +--+--+   +--+--+
 |  b  |   |  c  |
 +-----+   +-----+
```

---

## ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô

```rust,ignore
use std::rc::Rc;

fn main() {
    let a = Rc::new(String::from("hello"));

    println!("Count after a: {}", Rc::strong_count(&a)); // 1

    let b = Rc::clone(&a);  // ‡πÄ‡∏û‡∏¥‡πà‡∏° reference count
    println!("Count after b: {}", Rc::strong_count(&a)); // 2

    {
        let c = Rc::clone(&a);
        println!("Count in block: {}", Rc::strong_count(&a)); // 3
    } // c dropped, count -= 1

    println!("Count after block: {}", Rc::strong_count(&a)); // 2
}
```

> **‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏:** `Rc::clone` ‡πÑ‡∏°‡πà copy data ‡πÅ‡∏Ñ‡πà‡πÄ‡∏û‡∏¥‡πà‡∏° reference count

---

## Rc::clone vs .clone()

```rust,ignore
use std::rc::Rc;

fn main() {
    let a = Rc::new(vec![1, 2, 3]);

    // ‚úÖ Preferred: ‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô‡∏ß‡πà‡∏≤‡πÄ‡∏û‡∏¥‡πà‡∏° reference count
    let b = Rc::clone(&a);

    // ‚úÖ ‡∏Å‡πá‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ ‡πÅ‡∏ï‡πà‡∏≠‡∏≤‡∏à‡∏™‡∏±‡∏ö‡∏™‡∏ô‡∏Å‡∏±‡∏ö deep clone
    let c = a.clone();

    // Both b and c point to the same data
}
```

---

## Shared List Example

```rust,ignore
use std::rc::Rc;

enum List {
    Cons(i32, Rc<List>),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    // a = [5, 10, Nil]
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("Count after a: {}", Rc::strong_count(&a)); // 1

    // b = [3, -> a]
    let b = Cons(3, Rc::clone(&a));
    println!("Count after b: {}", Rc::strong_count(&a)); // 2

    // c = [4, -> a]
    let c = Cons(4, Rc::clone(&a));
    println!("Count after c: {}", Rc::strong_count(&a)); // 3

    // a ‡∏ñ‡∏π‡∏Å share ‡πÇ‡∏î‡∏¢ b ‡πÅ‡∏•‡∏∞ c
}
```

```text
b: Cons(3, --+
             |     +-------------------------+
             +---->| a: Cons(5, Cons(10, Nil))|
             +---->|                         |
             |     +-------------------------+
c: Cons(4, --+
```

---

## Rc\<T\> Properties

| Property        | Description                 |
| --------------- | --------------------------- |
| Single-threaded | ‡πÑ‡∏°‡πà thread-safe             |
| Immutable       | ‡πÑ‡∏î‡πâ‡πÅ‡∏Ñ‡πà `&T` ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ `&mut T` |
| No Copy         | ‡πÉ‡∏ä‡πâ Rc::clone()             |
| Automatic drop  | ‡πÄ‡∏°‡∏∑‡πà‡∏≠ count ‡πÄ‡∏õ‡πá‡∏ô 0          |

---

## Rc ‡∏Å‡∏±‡∏ö Methods

```rust,ignore
use std::rc::Rc;

fn main() {
    let a = Rc::new(String::from("hello"));

    // Deref ‡πÉ‡∏ä‡πâ methods ‡∏Ç‡∏≠‡∏á inner type ‡πÑ‡∏î‡πâ
    println!("Length: {}", a.len());
    println!("Uppercase: {}", a.to_uppercase());

    // Rc methods
    println!("Strong count: {}", Rc::strong_count(&a));

    // Get reference
    let s: &String = &a;
    println!("Ref: {}", s);
}
```

---

## Rc::downgrade ‡πÅ‡∏•‡∏∞ Weak

```rust,ignore
use std::rc::{Rc, Weak};

fn main() {
    let strong = Rc::new(5);
    let weak: Weak<i32> = Rc::downgrade(&strong);

    println!("Strong count: {}", Rc::strong_count(&strong)); // 1
    println!("Weak count: {}", Rc::weak_count(&strong));     // 1

    // Weak ‡∏ï‡πâ‡∏≠‡∏á upgrade ‡πÄ‡∏õ‡πá‡∏ô Rc ‡∏Å‡πà‡∏≠‡∏ô‡πÉ‡∏ä‡πâ
    if let Some(value) = weak.upgrade() {
        println!("Value: {}", value);
    }

    drop(strong); // strong dropped

    // Weak ‡∏¢‡∏±‡∏á upgrade ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ
    assert!(weak.upgrade().is_none());
}
```

> **Weak** ‡πÉ‡∏ä‡πâ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô reference cycles (‡∏î‡∏π‡∏ö‡∏ó 04-weak.md)

---

## ‡∏Ç‡πâ‡∏≠‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ç‡∏≠‡∏á Rc

```rust,ignore
use std::rc::Rc;

fn main() {
    let a = Rc::new(5);

    // ‚ùå Error: cannot borrow as mutable
    // *a += 1;

    // Rc ‡πÉ‡∏´‡πâ‡πÅ‡∏Ñ‡πà shared reference (&T)
    // ‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ mutate ‡πÉ‡∏ä‡πâ‡∏£‡πà‡∏ß‡∏°‡∏Å‡∏±‡∏ö RefCell
}
```

---

## Rc + RefCell Pattern

```rust,ignore
use std::rc::Rc;
use std::cell::RefCell;

fn main() {
    // Multiple owners + Interior mutability
    let value = Rc::new(RefCell::new(5));

    let a = Rc::clone(&value);
    let b = Rc::clone(&value);

    // ‡∏ó‡∏±‡πâ‡∏á a ‡πÅ‡∏•‡∏∞ b ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ mutate ‡πÑ‡∏î‡πâ
    *a.borrow_mut() += 10;
    *b.borrow_mut() += 10;

    println!("Value: {}", value.borrow()); // 25
}
```

---

## ‡∏•‡∏≠‡∏á‡∏ó‡∏≥‡∏î‡∏π! üéØ

1. ‡∏™‡∏£‡πâ‡∏≤‡∏á shared data ‡∏î‡πâ‡∏ß‡∏¢ Rc
2. Print strong_count ‡∏Ç‡∏ì‡∏∞ clone ‡πÅ‡∏•‡∏∞ drop
3. ‡∏•‡∏≠‡∏á combine Rc ‡∏Å‡∏±‡∏ö RefCell

---

## ‡∏™‡∏£‡∏∏‡∏õ

| Function                | ‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢                |
| ----------------------- | ----------------------- |
| `Rc::new(v)`            | ‡∏™‡∏£‡πâ‡∏≤‡∏á Rc ‡πÉ‡∏´‡∏°‡πà           |
| `Rc::clone(&rc)`        | ‡πÄ‡∏û‡∏¥‡πà‡∏° reference count   |
| `Rc::strong_count(&rc)` | ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô strong references |
| `Rc::weak_count(&rc)`   | ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô weak references   |
| `Rc::downgrade(&rc)`    | ‡∏™‡∏£‡πâ‡∏≤‡∏á Weak reference    |

### ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏´‡∏£‡πà‡πÉ‡∏ä‡πâ

| Situation                      | Use               |
| ------------------------------ | ----------------- |
| Single owner                   | ‡∏õ‡∏Å‡∏ï‡∏¥ (‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á Rc) |
| Multiple owners, single-thread | Rc                |
| Multiple owners, multi-thread  | Arc (‡∏ö‡∏ó‡∏ó‡∏µ‡πà 15)    |
| Mutability needed              | Rc + RefCell      |

üëâ ‡∏ï‡πà‡∏≠‡πÑ‡∏õ: [RefCell\<T\>](./03-refcell.md)
